<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Protocol Waveform Visualizer – I²C, SPI, UART</title>
  <style>
    :root{
      --bg: #0b0f1a;
      --panel: #0f172a;
      --panel-2: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --primary: #7c3aed;
      --primary-2: #06b6d4;
      --accent: #22c55e;
      --danger: #ef4444;
      --grid: #1f2937;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text); background: radial-gradient(1200px 800px at 20% -10%, rgba(124,58,237,.25), transparent 40%),
                 radial-gradient(1000px 700px at 120% 10%, rgba(6,182,212,.2), transparent 30%), var(--bg);
      min-height:100vh;
    }
    .wrap{max-width:1200px; margin:0 auto; padding:28px;}
    .title{display:flex; align-items:center; gap:12px;}
    .logo{width:44px;height:44px; display:grid; place-items:center; border-radius:12px; background:linear-gradient(135deg,var(--primary),var(--primary-2)); box-shadow: 0 10px 25px rgba(124,58,237,.25)}
    h1{font-size:clamp(20px,3vw,28px); margin:0}
    .panel{background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0)); border:1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px); border-radius:18px; padding:18px;}
    .grid{display:grid; grid-template-columns: 1.1fr .9fr; gap:18px;}
    @media (max-width: 980px){.grid{grid-template-columns:1fr}}

    label{font-size:12px; text-transform:uppercase; letter-spacing:.08em; color:var(--muted)}
    select, input[type="text"], button{
      width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:var(--panel);
      color:var(--text); outline:none; transition: .2s ease border-color, .2s ease transform;
    }
    select:hover, input[type="text"]:hover{border-color:rgba(255,255,255,.22)}
    input[type="text"]::placeholder{color:#6b7280}
    button{cursor:pointer; font-weight:600; background:linear-gradient(135deg,var(--primary),var(--primary-2)); border:none; box-shadow: 0 8px 24px rgba(124,58,237,.25)}
    button:hover{transform: translateY(-1px)}
    button:active{transform: translateY(0)}

    .controls{display:grid; grid-template-columns: repeat(12, 1fr); gap:12px}
    .span-3{grid-column: span 3}
    .span-6{grid-column: span 6}
    .span-9{grid-column: span 9}
    .span-12{grid-column: span 12}
    @media (max-width: 820px){.span-3,.span-6,.span-9{grid-column: span 12}}

    .info{font-size:13px; color:var(--muted); line-height:1.6}

    .scope{position:relative; overflow:auto; border-radius:16px; background: var(--panel-2); border:1px solid rgba(255,255,255,.08)}
    .scope-inner{min-width:800px; position:relative}
    .legend{display:flex; flex-wrap:wrap; gap:8px 14px; align-items:center; padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.06); background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0)); position:sticky; top:0; z-index:3}
    .legend .dot{width:10px;height:10px;border-radius:50%}

    .row{display:grid; grid-template-columns: 140px 1fr; align-items:center; gap:0; border-top:1px solid rgba(255,255,255,.06)}
    .row:first-of-type{border-top:none}
    .row .label{padding:10px 12px; color:#cbd5e1; font-size:12px; background: rgba(255,255,255,.02)}
    .row .track{position:relative; height:74px;}

    svg{display:block; width:100%; height:100%}
    .gridlines{stroke:var(--grid); stroke-width:1}
    .bit-label{font-size:11px; fill:#94a3b8}
    .anno{font-size:11px; fill:#a7f3d0}

    .footer{margin-top:10px; display:flex; gap:10px; align-items:center; justify-content:space-between; color:#94a3b8; font-size:12px}
    .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border:1px solid rgba(255,255,255,.08); border-radius:999px; background:rgba(255,255,255,.03)}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; background:#0b1220; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.08)}
    .error{color:var(--danger); font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <div class="logo">⚡</div>
      <h1>Protocol Waveform Visualizer <span style="opacity:.6">— I²C · SPI · UART</span></h1>
    </div>

    <div class="grid" style="margin-top:16px">
      <section class="panel">
        <div class="controls">
          <div class="span-3">
            <label for="protocol">Protocol</label>
            <select id="protocol">
              <option value="i2c">I²C</option>
              <option value="spi">SPI (Mode 0)</option>
              <option value="uart">UART (8N1)</option>
            </select>
          </div>
          <div class="span-6">
            <label for="data">Data (hex like 0xA5 or A5; or binary like 1010_0101)</label>
            <input id="data" type="text" placeholder="e.g., 0xA5 or 1010_0101" />
          </div>
          <div class="span-3">
            <label>&nbsp;</label>
            <button id="go">Go ▷</button>
          </div>

          <div class="span-12 info" id="hint">
            Tip: I²C shows START, 8 data bits (MSB→LSB) and ACK; SPI shows CS#, SCLK and MOSI (MSB first, mode 0); UART shows idle, START, 8 data bits (LSB first), STOP.
          </div>
          <div class="span-12 error" id="error"></div>
        </div>
      </section>

      <section class="panel">
        <div style="display:grid; gap:10px">
          <div>
            <div class="pill">Made for DV practice — visualize how bits ride the wires.</div>
          </div>
          <div class="info">
            <strong>How it works</strong><br/>
            Enter a byte (or multiple bytes). The tool parses your input and renders timing-level waveforms for the selected protocol using scalable SVG. Use the output as an aid for debugging or explaining transactions in interviews.
          </div>
          <div class="info">
            <strong>Input examples</strong><br/>
            <span class="kbd">0xDEAD</span> · <span class="kbd">DE AD</span> · <span class="kbd">1010_1100 0001_1111</span>
          </div>
          <div class="info">
            <strong>Assumptions</strong><br/>
            I²C: single byte + ACK (stretch-free). SPI: Mode 0, MSB first. UART: 8N1, LSB first. Scales horizontally with data length.
          </div>
        </div>
      </section>
    </div>

    <section class="panel scope" style="margin-top:18px">
      <div class="legend">
        <div class="pill"><div class="dot" style="background:#a78bfa"></div> Clock</div>
        <div class="pill"><div class="dot" style="background:#67e8f9"></div> Data</div>
        <div class="pill"><div class="dot" style="background:#fda4af"></div> CS#/Line state</div>
        <div class="pill"><div class="dot" style="background:#86efac"></div> Annotations</div>
      </div>
      <div class="scope-inner" id="scope"></div>
      <div class="footer">
        <div>Click <span class="kbd">Go</span> to (re)draw. Pan horizontally by scrolling. SVG scales with window size.</div>
        <div>© Protocol Visualizer</div>
      </div>
    </section>
  </div>

  <script>
    // ---------- Utilities ----------
    const byId = (id)=>document.getElementById(id);

    function parseInput(str){
      if(!str) throw new Error("Please enter some data");
      str = str.trim().replace(/_/g, ' ').replace(/\s+/g,' ').toUpperCase();
      const bytes = [];
      const tokens = str.split(' ');
      for(const t of tokens){
        if(!t) continue;
        let token=t;
        if(/^0X[0-9A-F]+$/.test(token)) token = token.slice(2);
        if(/^[01]+$/.test(token)){
          // binary string -> group into bytes (pad left)
          let bin = token;
          const pad = (8 - (bin.length % 8)) % 8;
          bin = '0'.repeat(pad) + bin;
          for(let i=0;i<bin.length;i+=8){
            bytes.push(parseInt(bin.slice(i,i+8),2));
          }
        } else if(/^[0-9A-F]+$/.test(token)){
          // hex -> group by 2
          let hex = token;
          if(hex.length%2===1) hex='0'+hex;
          for(let i=0;i<hex.length;i+=2){
            bytes.push(parseInt(hex.slice(i,i+2),16));
          }
        } else {
          throw new Error(`Cannot parse token: "${t}"`);
        }
      }
      if(bytes.length===0) throw new Error("No data parsed");
      return bytes;
    }

    function bitsFromByte(byte, msbFirst=true){
      const bits=[];
      if(msbFirst){
        for(let i=7;i>=0;i--) bits.push((byte>>i)&1);
      }else{
        for(let i=0;i<8;i++) bits.push((byte>>i)&1);
      }
      return bits;
    }

    // ---------- Waveform construction helpers ----------
    // Build track as array of segments: {level:0|1, len: integer time units, label?:string, at?:'center'|'start'|'end'}
    function pushSeg(track, level, len, label){ track.push({level, len, label}); }

    function totalLen(tracks){
      return Math.max(...tracks.map(tr=>tr.reduce((s,x)=>s+x.len,0)));
    }

    // Create SVG for given tracks (array of rows). Each row: {name, color, segments}
    function renderSVG(rows, annotations){
      const unitW = 26; // px per time unit
      const rowH = 74;  // px per row
      const padL = 10, padR = 20;
      const W = totalLen(rows.map(r=>r.segments)) * unitW + padL + padR;
      const H = rows.length * rowH;

      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS,'svg');
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

      // vertical gridlines
      const grid = document.createElementNS(svgNS,'g');
      let gridX = 0; const gridStep = unitW;
      while(gridX <= W){
        const line = document.createElementNS(svgNS,'line');
        line.setAttribute('x1', gridX+0.5); line.setAttribute('y1', 0);
        line.setAttribute('x2', gridX+0.5); line.setAttribute('y2', H);
        line.setAttribute('class','gridlines');
        grid.appendChild(line);
        gridX += gridStep;
      }
      svg.appendChild(grid);

      // draw each row
      rows.forEach((row, idx)=>{
        const yTop = idx*rowH; const midY = yTop + rowH/2;
        // label
        const label = document.createElementNS(svgNS,'text');
        label.setAttribute('x', 8); label.setAttribute('y', yTop + 18);
        label.setAttribute('class','bit-label');
        label.textContent = row.name;
        svg.appendChild(label);

        let x = padL; const high = yTop + 18; const low = yTop + 54;
        let path = `M ${x} ${row.segments[0]?.level?high:low}`;
        row.segments.forEach(seg=>{
          const nx = x + seg.len*unitW;
          // horizontal
          path += ` H ${nx}`;
          // vertical to next level if next exists
          x = nx;
          // peek next
          const next = row.segments[row.segments.indexOf(seg)+1];
          if(next){
            path += ` V ${next.level?high:low}`;
          }
        });
        const p = document.createElementNS(svgNS,'path');
        p.setAttribute('d', path);
        p.setAttribute('fill','none');
        p.setAttribute('stroke', row.color);
        p.setAttribute('stroke-width','2.2');
        svg.appendChild(p);

        // bit labels centered on segments
        let cursor = padL;
        row.segments.forEach(seg=>{
          if(seg.label){
            const tx = cursor + seg.len*unitW/2; const ty = yTop + rowH - 10;
            const t = document.createElementNS(svgNS,'text');
            t.setAttribute('x', tx); t.setAttribute('y', ty);
            t.setAttribute('text-anchor','middle');
            t.setAttribute('class','bit-label');
            t.textContent = seg.label;
            svg.appendChild(t);
          }
          cursor += seg.len*unitW;
        });
      });

      // annotations (green)
      if(Array.isArray(annotations)){
        annotations.forEach(a=>{
          const t = document.createElementNS(svgNS,'text');
          t.setAttribute('x', a.x);
          t.setAttribute('y', a.y);
          t.setAttribute('class', 'anno');
          t.setAttribute('text-anchor', a.anchor||'start');
          t.textContent = a.text;
          svg.appendChild(t);
        });
      }

      return svg;
    }

    // ---------- Protocol builders ----------

    function buildI2C(bytes){
      // Lines: SCL (clock), SDA (data). Idle high.
      const scl=[], sda=[]; const ann=[];
      // Idle
      pushSeg(scl,1,2); pushSeg(sda,1,2);
      // START: SDA falls while SCL high
      pushSeg(sda,0,1, 'START'); pushSeg(scl,1,1);
      // Data bits MSB first, one bit per SCL cycle: low phase + high phase
      for(const b of bytes){
        const bits = bitsFromByte(b, true);
        bits.forEach((bit, idx)=>{
          // data stable while SCL high, change while SCL low
          pushSeg(scl,0,1);
          pushSeg(sda,bit,1, `D${7-idx}:${bit}`);
          pushSeg(scl,1,1);
          pushSeg(sda,bit,1);
        });
        // ACK bit from slave (pull SDA low during SCL high)
        pushSeg(scl,0,1);
        pushSeg(sda,0,1, 'ACK');
        pushSeg(scl,1,1);
        pushSeg(sda,0,1);
      }
      // STOP: SDA rises while SCL high
      pushSeg(scl,1,1); pushSeg(sda,1,1,'STOP');
      return {rows:[
        {name:'SCL', color:'#a78bfa', segments:scl},
        {name:'SDA', color:'#67e8f9', segments:sda}
      ], ann};
    }

    function buildSPI(bytes){
      // Mode 0: CPOL=0 (idle low), CPHA=0 (sample on rising edge). MSB first.
      const cs=[], sclk=[], mosi=[];
      // CS# low to select
      pushSeg(cs,1,2); // idle high
      pushSeg(cs,0,2,'CS# low');
      // Small lead time
      pushSeg(sclk,0,1); pushSeg(mosi,0,1);
      for(const b of bytes){
        const bits = bitsFromByte(b, true);
        bits.forEach((bit, idx)=>{
          // set data while clock low
          pushSeg(sclk,0,1);
          pushSeg(mosi,bit,1, `b${7-idx}:${bit}`);
          // rising edge (sample)
          pushSeg(sclk,1,1);
          pushSeg(mosi,bit,1);
        });
      }
      // return to idle
      pushSeg(sclk,0,1);
      pushSeg(cs,1,2,'CS# high');
      return {rows:[
        {name:'CS#', color:'#fda4af', segments:cs},
        {name:'SCLK', color:'#a78bfa', segments:sclk},
        {name:'MOSI', color:'#67e8f9', segments:mosi}
      ], ann:[]};
    }

    function buildUART(bytes){
      // UART 8N1: idle high, start low, 8 data bits LSB-first, stop high.
      const tx=[]; const ann=[];
      pushSeg(tx,1,2,'Idle');
      for(const b of bytes){
        // start bit
        pushSeg(tx,0,2,'START');
        const bits = bitsFromByte(b, false); // LSB-first
        bits.forEach((bit, idx)=> pushSeg(tx,bit,2, `d${idx}:${bit}`));
        // stop bit
        pushSeg(tx,1,2,'STOP');
      }
      return {rows:[{name:'TX', color:'#67e8f9', segments:tx}], ann};
    }

    function draw(){
      byId('error').textContent='';
      const scope = byId('scope'); scope.innerHTML='';
      try{
        const proto = byId('protocol').value;
        const bytes = parseInput(byId('data').value);
        let built;
        if(proto==='i2c') built = buildI2C(bytes);
        else if(proto==='spi') built = buildSPI(bytes);
        else built = buildUART(bytes);

        // Assemble rows with labels at left; renderSVG expects rows array
        const rows = built.rows.map((r,i)=>({name:r.name, color:r.color, segments:r.segments}));
        const svg = renderSVG(rows, built.ann);
        scope.appendChild(svg);
      }catch(e){
        byId('error').textContent = e.message;
      }
    }

    byId('go').addEventListener('click', draw);
    // Demo default
    byId('data').value = '0xA5';
    draw();
  </script>
</body>
</html>
